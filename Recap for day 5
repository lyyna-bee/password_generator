ğŸ”‘ Password Generator Recap (Day 5 Practice)

1. Lists
- Created three lists: letters, numbers, symbols.
- Used them as pools to draw random characters from.

2. Randomization
- random.randint(a, b) â†’ generates a random integer between a and b.
- random.choices(list, k=n) â†’ picks n random elements (duplicates allowed).
- random.sample(list, k=n) â†’ picks n random elements (no duplicates).
- random.shuffle(list) â†’ shuffles the order of items in a list.

3. User Input
- input() â†’ lets the user type values.
- Wrapped in int() to convert input into numbers.
- Used while True loops to validate input until itâ€™s correct.

4. Password Length
- Ensured passwords are never shorter than 8 characters.
- Either:
- Let the user set the exact length, or
- Let the program choose a random length between 8 and a userâ€‘defined maximum.

5. Splitting Logic
- Guaranteed at least one letter, one number, and one symbol:

nr_letters = random.randint(1, password_length - 2)
nr_numbers = random.randint(1, password_length - nr_letters - 1)
nr_symbols = password_length - nr_letters - nr_numbers

- Ensures the total always equals password_length.

6. Multiple Passwords
- Used a for loop to generate several passwords in one run:

for i in range(num_passwords):
    # generate password here
    print(f"{i+1}: {password}")


7. Debugging
- Fixed indentation errors by keeping the password generation logic inside the loop.
- Fixed NameError by ensuring variables are only used inside the correct else: block.
- Learned why random.choices was better than random.sample for passwords (duplicates allowed).

âœ¨ Sneak peek for tomorrow (Day 6 â€“ Functions): Youâ€™ll learn to wrap this logic into a reusable function like:

def generate_password(length):
    # password logic here
    return password


Then you can call generate_password(12) as many times as you want.

when you start learning functions, remember that they can take parameters (inputs) and return outputs. That means you can give your function â€œsettingsâ€ to control how it behaves.
For example, imagine you want your password generator to let the user decide whether to include symbols or not. You could write:

def generate_password(length, use_symbols=True):
    import random
    letters = list("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
    numbers = list("0123456789")
    symbols = list("!@#$%^&*()-_=+[]{};:,.<>?/")

    nr_letters = random.randint(1, length - 2)
    nr_numbers = random.randint(1, length - nr_letters - 1)
    nr_symbols = length - nr_letters - nr_numbers if use_symbols else 0

    password_letters = random.choices(letters, k=nr_letters)
    password_numbers = random.choices(numbers, k=nr_numbers)
    password_symbols = random.choices(symbols, k=nr_symbols) if use_symbols else []

    password_list = password_letters + password_numbers + password_symbols
    random.shuffle(password_list)

    return "".join(password_list)

ğŸ”‘ Why this is cool:
- length â†’ user decides how long the password should be.
- use_symbols=True â†’ by default, symbols are included.
- If you call generate_password(12, use_symbols=False), youâ€™ll get a password with only letters and numbers.

âœ¨ Tiny takeaway: Functions are like miniâ€‘machines. You feed them inputs (parameters),
                    they do their job, and they give you an output (return value).
